[{"content":"After restoring an AWS RDS database from a snapshot, RDS only lazy loads data from S3 as and when it\u0026rsquo;s required, which for large tables can cause some initial slowness and quite a lot of I/O.\nhttps://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_RestoreFromSnapshot.html\nTo help mitigate the effects of lazy loading on tables to which you require quick access, you can perform operations that involve full-table scans, such as SELECT *. This allows Amazon RDS to download all of the backed-up table data from S3.\n","date":"24 May 2025","permalink":"https://mattbell.dev/til/rds-snapshot-cold-start/","section":"Today I Learned","summary":"","title":"AWS RDS cold starts"},{"content":"","date":null,"permalink":"https://mattbell.dev/","section":"Home","summary":"","title":"Home"},{"content":"Little things I\u0026rsquo;ve learned over time\n","date":null,"permalink":"https://mattbell.dev/til/","section":"Today I Learned","summary":"","title":"Today I Learned"},{"content":"Recently I learned AWS CloudFormation supports Extensions, 3rd party modules you can enable to add resources from other cloud providers to your CloudFormation stack. This is useful if you\u0026rsquo;re not \u0026ldquo;all in\u0026rdquo; on AWS and have resources in other vendors that are related to resources in your stack, such as Datadog Monitors or PagerDuty services.\nhttps://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/registry-public.html\nThe annoying thing is you can\u0026rsquo;t configure CloudFormation extensions with IAC, only with the AWS CLI, meaning if you have a multi account setup it\u0026rsquo;s more of a pain than it should be to ensure all relevant accounts have properly configured extensions.\n","date":"10 April 2025","permalink":"https://mattbell.dev/til/cloudformation-extensions/","section":"Today I Learned","summary":"","title":"AWS CloudFormation Extensions"},{"content":"I\u0026rsquo;ve used combinations of nginx and apache at work for almost 15 years now, but I don\u0026rsquo;t think I\u0026rsquo;ve ever had to migrate configuration from one to the other.\nThis week I lost a few hours by a surprising and subtle difference in how the proxypass directive works in nginx.\nHere\u0026rsquo;s a docker-compose.yml that starts two nginx servers, one proxying requests to another:\n--- services: nginx-proxy: image: nginx:latest container_name: proxy ports: - \u0026#34;8080:80\u0026#34; volumes: - ./proxy.conf:/etc/nginx/nginx.conf depends_on: - nginx-backend nginx-backend: container_name: backend image: nginx:latest ports: - \u0026#34;8081:80\u0026#34; volumes: - ./backend.conf:/etc/nginx/nginx.conf The config for the proxy looks like this:\nevents {} http { server { listen 80; # proxy_pass without a trailing slash location /novar/notrailing/ { proxy_pass http://backend:8081; } # proxy_pass with a trailing slash location /novar/trailing/ { proxy_pass http://backend:8081/; } # proxy_pass using a variable to set the upstream host, without a trailing slash location /var/notrailing/ { set $upstream http://backend:8081; proxy_pass $upstream; } # proxy_pass using a variable to set the upstream host, with a trailing slash location /var/trailing/ { set $upstream http://backend:8081/; proxy_pass $upstream; } } } And the config for the backend is below. It\u0026rsquo;s configured to return a 200 for any request and the request URI it received from the proxy.\nevents {} http { server { listen 8081; location / { add_header Content-Type text/plain; return 200 \u0026#34;$request\u0026#34;; } } } Starting the servers:\ndocker compose up -d Now to compare the behaviour when using variables and trailing slashes in the proxy_pass directive.\nNo variable, no trailing slash #Without a trailing slash, nginx proxies the full request URI through to the backend:\n❯ curl localhost:8080/novar/notrailing/test/ /novar/notrailing/test/ No variable, with a trailing slash #With a trailing slash, nginx removes the matching part of the URI (/novar/trailing) and passes through the rest (/test/)\n❯ curl localhost:8080/novar/trailing/test/ /test/ Using a variable for the host, without a trailing slash #One of the reasons to use a variable when setting the upstream host in the proxy_pass directive is to stop nginx attempting to resolve the domain at startup. But this causes a subtle change in behaviour.\nFirst off, with no trailing slash, everything works as before and the whole URI is passed through:\n❯ curl localhost:8080/var/notrailing/test/ /var/notrailing/test/ Using a variable for the host, with a trailing slash #With a trailing slash though, none of the URI is passed through!\n❯ curl localhost:8080/var/trailing/test/ / ","date":"2 March 2025","permalink":"https://mattbell.dev/til/nginx-vars-trailing-slashes/","section":"Today I Learned","summary":"","title":"Nginx, apache and trailing slashes"},{"content":"","date":null,"permalink":"https://mattbell.dev/posts/","section":"Blog","summary":"","title":"Blog"},{"content":"Another site redesign! I have a Medium account but end up with a lot of draft posts that I never make public. So I wanted to make it as easy as possible for me to write more often.\nI settled on using the Hugo static site generator with the Congo theme hosted on Github Pages.\nI can now create new content by creating a markdown file in my public github repo under content/posts, and also run it locally by just running hugo serve.\n","date":"1 March 2025","permalink":"https://mattbell.dev/posts/start/","section":"Blog","summary":"","title":"More than just a links page"}]